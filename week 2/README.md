# 2주차 : UPDOWN 숫자 맞추기 프로그램

1. 숫자를 얻어와서 프로그램에서 랜덤으로 할당한 값과 일치하는지 판별
  - 비순수/순수 함수 하나씩 포함해서 코드 짜기(addcount())로 설정
  - 게임오버/정답을 맞출 시 게임리셋 버튼 나오게 하기 / 입력창 및 submit 버튼 비활성화
  - 게임 리셋 시 입력창 및 submit버튼 활성화
  - 값 입력 시 오답 시 자신이 입력했던 숫자 출력되게 하기

* 11 ~ 18장 까지

<img src="https://user-images.githubusercontent.com/86109399/229349372-06d0701b-e0f7-4ac5-ae92-070242f27b2d.png">

# 보고서 #1 var, let, const 키워드와 블록 레벨 스코프

var, let, const 키워드를 정확히 알기 위해서는, 변수의 선언 및 할당 과정, 호이스팅, 스코프를 알아야한다.

**변수**는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 

변수에 값을 저장하는 것을 **할당**이라 하며 변수에 저장된 값을 읽어 들이는 것을 **참조**라 한다. 그리고 변수명을 자바스크립트 엔진에 알리는 것을 **선언**이라 한다.


## 변수 선언

변수의 선언은 var, let, const 키워드로 할 수 있다. ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었고 ES6에서 const와 let이 추가되었다.

자바스크립트에서 변수 선언은 **선언 -> 초기화** 단계를 거쳐 수행한다.
- **선언 단계** : 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

```javascript
var mingi;
console.log(mingi); // undefined
```
 var 키워드를 이용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행되어, mingi에 암묵적으로 undefined를 할당해 초기화한다.

```javascript
console.log(mingi); // undefined
var mingi;
```
 그런데 반대로, console을 먼저 실행하여도 반환 값은 undefined로 나온다. 이는 변수 선언이 런타임에 되는 것이 아니라, 그 이전 단계에 먼저 실행되기 때문이다. 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다.

변수 선언 뿐만 아니라, var, let, const, function, class 키워드를 사용해 선언한 모든 식별자(변수, 함수, 클래스 등)는 호이스팅이 된다.

## 변수 할당
변수에 값을 할당할 때에는 할당 연산자(=)를 사용한다.

```javascript
var mingi; // 변수 선언
mingi = 'jumingi'; // 값의 할당

var mingi = 'jumingi'; // 변수 선언과 할당
```
 변수 선언과 할당은 하나의 문으로 단축 표현할 수 있지만, 두 개의 실행 시점이 다르다. 변수 선언이 호이스팅되어 런타임 이전에 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.

따라서 변수의 할당과 console을 실행하는 위치에 따라 반환되는 값이 다르다.

```javascript
console.log(mingi); // undefined

var mingi = 'jumingi';
console.log(mingi); // jumingi
```


## 스코프
**스코프**는 식별자(변수명, 함수명, 클래스명 등)의 유효범위를 뜻하며, 선언된 위치에 따라 유효범위가 달라진다. 전역에 선언된 변수는 전역 스코프, 지역에 선언된 변수는 지역 스코프를 갖는다.

전역 변수는 어디에서든지 참조가 가능한 값이다. 반면, 지역 변수는 함수 몸체 내부를 말한다. 따라서 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다.

자바스크립트에서 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만들며, 이러한 특성을 **블록 레벨 스코프**라 한다. 하지만 var 키워드로 선언된 변수는 함수의 코드 블록만을 지역 스코프로 인정한다. 이를 **함수 레벨 스코프**라 한다.

```javascript
var a=2;

if(true) {
    a = 3;
}

console.log(a); // 3
```
 예제를 보면 함수가 아닌 곳에서 var 키워드를 이용하여 a를 선언했기 때문에 전역 변수로 취급한다. 기존에 있던 a 변수가 중복 선언되면서, 출력값이 3으로 바뀐 것을 알 수 있다.

 **var 키워드**를 사용하면 전역 변수로 인해 재할당이 발생하거나, 전역 스코프를 공유하기 때문에 어딘가에 동일한 이름이 있다면 예상치 못한 결과가 발생할 위험이 있다. 따라서 함수 코드 블록만을 지역 스코프로 인정하는 var 키워드 대신에, 블록 레벨 스코프를 지원하는 **const와 let 키워드**를 사용하는 것을 권장한다.

### var 키워드의 문제점 정리
- 변수 중복 선언이 가능하여, 예기치 못한 값을 반환할 수 있다.
- 함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 취급한다.
- 변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.


## let, const 키워드의 특징

### 1. 변수 중복 선언 불가

#### 1-1. let
let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다.
```javascript
let name = 'fuckyou';
console.log(name); // fuckyou

let name = 'f'; // X

name = 'mom';
console.log(name); // mom
```

#### 1-2. const
const 키워드는 반드시 선언과 초기화를 동시에 진행되어야 한다.

```javascript
const name; // X
const name = 'fuck';
```
 재선언과 재할당도 불가하다. 


```javascript
// 원시값의 재할당
const name = 'fuck';
name = 'mom'; // X

// 객체의 재할당
const name = {
    eng: 'fuck'
}
name.eng = 'mom';

console.log(name) // { eng: "mom" }
```
 하지만 재할당의 경우 원시값은 불가능하지만, 객체는 가능하다. const 키워드는 재할당을 금지할 뿐, ‘불변’을 의미하지 않는다.

### 2. 블록 레벨 스코프
let, const 키워드로 선언한 변수는 모두 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```javascript
let a = 2;

if(true) {
    let a = 5;
}

console.log(a); // 2
```
 아까 전 var 키워드로 선언한 경우와 달리 let 키워드로 선언한 경우 if 문 안에 있는 것은 지역 스코프를 가져 전역에서 console을 출력할 경우, 전역에 있는 a가 결과값으로 출력된다.
 (const 키워드도 동일하게 동작한다.)


### 3. 변수 호이스팅

#### 3-1 let
let 키워드로 선언한 변수는 **선언 단계와 초기화 단계가 분리되어 진행**된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 실행되지만, 초기화 단계가 실행되지 않았을 때 해당 변수에 접근하려고 하면 참조 에러가 뜬다.
```javascript
console.log(name); // X

let name = 'fuck';
```
 따라서 let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는 **일시적 사각지대** 구간에 존재한다.


#### 3-2 const
const 키워드는 선언 단계와 초기화 단계가 동시에 진행된다.
```javascript
console.log(name); // X

const name = 'fuck';
```
 const 키워드로 선언하는 경우, 선언과 초기화가 동시에 이루어져야 하지만 런타임 이전에는 실행될 수 없다. 따라서 초기화가 되지 않은 상태이기 때문에 오류가 뜬다.